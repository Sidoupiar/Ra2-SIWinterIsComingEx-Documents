# 标记逻辑说明

所有单位都可以被添加标记，一种标记在一个单位身上只能同时挂载一个，如果多次挂载相同的标记，那么它们的持续时间会叠加。  
标记分为四种状态，挂载（Mark），激发（Active），生效（Effect），结束（After），四种状态可以通过一定的方式互相切换。  
并且由四种状态衍生出两个生命周期，挂载期间，激发期间。

### 注意

* 标记的持续时间结束之后标记会被立刻移除，即使它刚生效到一半。

* *标记效果的结算顺序是由标记的 Order 属性决定的，举个栗子，一个减伤标记 Order=0，一个承伤标记 Order=1，那么就是受到伤害时先减伤再承伤。

* 标记效果对于防御力加成的支持暂时有一定的局限性，不支持扩展平台的各种防御力加成（AE 效果除外），如果单位拥有这些防御力加成，那么伤害结算可能会有偏差。



## 状态说明

|状态|说明|
|-|-|
|挂载|单位持有标记，但是标记不会带来任何效果，仅仅就是一个标记而已，四个阶段均属于挂载期间。|
|激发|已经通知标记生效，但是基于设置，标记可能无法立刻生效，这一期间属于激发，另外生效期间也属于激发期间。|
|生效|标记的效果发挥出来了，标记会按照挂载的顺序逐个计算效果。|
|结束|此标记已经发挥作用完毕，无法再被激发了。|



## 生命周期

|生命周期|说明|
|-|-|
|挂载期间|从单位获得标记一直到给定的持续时间结束，或一直持续到标记被移除，只要标记处在挂载期间就可以被检测到。|
|激发期间|从标记被激发一直到标记生效结束，或一直持续到标记被移除。|



## 标记的生命周期时间顺序图

时间顺序从左到右：

（画不出来）

### 注意

* 单位被超时空冻结后，标记的时间会暂停。



## 处理阶段

不同的标记效果会在不同的处理阶段参与处理，处理顺序（Order 属性）只能影响当前处理阶段参与处理的标记。  
目前标记的处理阶段一共有 8 个，分别是：主动（StageActive），自身（StageSelf），开火（StageFire），攻击（StageAttack），防御（StageDefend），受伤（StageDamaged），治疗（StageHealed），亡语（StageDead）。

一般情况下各个处理阶段的先后顺序：（这些处理阶段之间的先后顺序不是绝对固定的，实际过程中彼此之间会有所穿插）

（画不出来）

### 备注

1. 在【防御处理阶段】处理的是原始伤害（即结算护甲前的伤害）。

2. 受到正伤害（和由标记的效果种类产生的 0 伤害）时会进入【受伤处理阶段】，受到负伤害时会进入【治疗处理阶段】。

3. 在【受伤处理阶段】和【治疗处理阶段】中使用统一的处理顺序以保证正确处理所有相关的标记
因此，在【受伤处理阶段】时，如果处理某一个标记后伤害变为负值（即变成治疗型伤害），则后续会接下一个标记的【治疗处理阶段】，反过来也如此。

### 注意

* 如果在处理阶段中向单位添加的新的标记，则这个标记在当前处理阶段中不会被处理，即便它的处理顺序非常靠后。



## 概念：自动状态切换

标记是可以进行自动状态切换的。  
状态切换的核心就是几个计时相关的属性，它们决定了何时切换何种状态。  
在任何状态中间，均可以使用切换状态类型的效果立即改变标记的状态。

在默认的自动状态切换中，**生效状态** -> **结束状态** 的切换至少持续 **1** 帧，而其余的状态都可以立即切换。  
此行为可以被一部分效果种类影响，也可以被切换状态类型的效果改变。



## 概念 : 强度值叠加

强度值叠加代替了标记叠层。  
若标记允许重复激发，则激发时附带的强度值会相互叠加，调整标记的强度值类效果不受此限制，单纯叠强度值不能激发标记，不激发便没有实际效果。  
这种方式在一定程度上避免了叠层带来的性能开销，代价就是无法更新挂载标记的单位（无法更新标记来源），相同标记叠加只能叠加持续时间。

### 公式

新强度值 = 原强度值 + 被附加的强度值

通常情况下，  
标记进入挂载状态和结束状态时会重置强度值。



## 概念：强度值转换

大多数标记效果中都存在强度值转换的概念。  
这是把标记的强度值转换为标记的实际效果强度的方式。  
强度值是叠层的代替品，这种方式在一定程度上避免了叠层带来的性能开销。

### 公式

实际参与计算的强度值 = min( max( 标记当前的强度值 , 参与计算的强度值下限 ) , 参与计算的强度值上限 )  
实际效果强度         = min( max( 效果的基础数值 + 实际参与计算的强度值 * 强度值的转换效率 , 效果的数值下限 ) , 效果的数值上限 )  
实际数值             = min( max( 对应数据的数值 +-*/ 实际效果强度 , 实际数值的数值下限 ) , 实际数值的数值上限 )  

|参数|说明|
|-|-|
|效果的基础数值       |由 Power.Bases 属性指定，默认值是 0。|
|强度值的转换效率     |由 Power.Mults 属性指定，默认值是 0。|
|效果的数值上限       |由 Power.Maxs 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|
|效果的数值下限       |由 Power.Mins 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|
|实际数值的数值上限   |由 Power.Maxs.Total 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|
|实际数值的数值下限   |由 Power.Mins.Total 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|
|参与计算的强度值上限 |由 Power.Maxs.Real 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|
|参与计算的强度值下限 |由 Power.Mins.Real 属性指定，None 或 N = 不限制，默认值是 None（不区分大小写）。|

### 注意

* 上下限互相冲突（即下限高于上限）时，上下限的限制失效，会被认为是不限制，而实际数值的上下限冲突可能导致效果被无效（具体情况取决于效果种类的具体参数项）。

* 通常情况下，【所占比例】，【生命值】，【次数】相关的数值都只能是非负数；而【恢复量】，【伤害】，【增幅】相关的数值则可以是任何数值，负值有可能会反转效果。

### 写法

强度值转换由以下 8 条属性组成：（全部都是浮点数，使用默认值的项可以不写）  
Power.Bases=0  
Power.Mults=0  
Power.Maxs=None  
Power.Mins=None  
Power.Maxs.Total=None  
Power.Mins.Total=None  
Power.Maxs.Real=None  
Power.Mins.Real=None

其中的每一项都代表定义了 **1** 项参数。

如果一个效果种类要求 3 项参数，就写成如下形式：（缺项则缺少的那一项使用默认值）
Power.Bases=0,0,0  
Power.Mults=0,0,0  
Power.Maxs=None,None,None  
Power.Mins=None,None,None  
Power.Maxs.Total=None,None,None  
Power.Mins.Total=None,None,None  
Power.Maxs.Real=None,None,None  
Power.Mins.Real=None,None,None