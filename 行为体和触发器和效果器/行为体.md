# 行为体



## 什么是行为体？

行为体（Behavior）是可以**独立刷新数据**的实体，常见的单位、作战方、抛射物、WBuff、精灵等等都是行为体。  
这些实体共有的特点就是可以独自响应玩家的操作，还可以脱离其他实体而独立存在。  

所有的行为体都可以支持添加触发器、支持添加任意种类的 WBuff。  
⚠️不是所有种类的行为体都可以触发所有种类的的触发器，它不是不触发而是行为体可能没有这方面的能力。  
🌰你在【作战方】这个行为体上绑定了【被攻击触发器】，它显然就是无法触发的，因为作战方压根就不会被攻击命中。

### 行为体的生命周期

不同种类的行为体生命周期是不一样的：

|行为体种类|生命周期开始|生命周期结束|
|:-:|:-|:-|
|单位（Techno）|通过生产、空投等等各种方式入场|通过生命值耗尽、回收、消失等等方式离场|
|作战方（House）|游戏开始|游戏结束|
|抛射物（Bullet）|武器开火时|命中目标并爆炸|
|领域（Area）|被创建|被移除|
|精灵（Fairy）|通过武器、动作等等方式创建|通过寿命耗尽、生命周耗尽等等方式消失|
|副官（Assist）|启用|解雇|
|WBuff|挂载|移除|



## 记忆体与标签

每个行为体都可以拥有一组独立工作的标签（`Tag`），标签数量不限，相同的标签会彼此覆盖，任何名称相同的标签会被视为是同一个标签。新建行为体时，行为体会获得原型中定义的所有标签。  
标签拥有一个整数类型的参数————`标签值`，`标签值`可以作为判定标签的额外条件，当相同的标签进行覆盖时，可以决定它们的`标签值`是合并、扣除还是替换。  
在行为体的生命周期内，可以通过任何可以修改标签的方式调整标签和`标签值`。

⚠️标签的`标签值`可以是负数，但是只有`标签值`大于 0 时才会被视为拥有这个标签。

```ini
[SomeBehaviorPrototype]
; 继承自 RawTaggablePrototype
Tags=                                                       ; 标签列表 , 标签名字可以是纯数字以外的任意字符组合 , 不要超过 32 个字符
                                                            ; 可以在标签后面跟随一个整数来定义标签值 , 如果不填写的话就使用默认值 1
TagsRandom=                                                 ; 标签列表 , 标签名字可以是纯数字以外的任意字符组合 , 不要超过 32 个字符
                                                            ; 可以在标签后面跟随一个整数来定义标签值 , 如果不填写的话就使用默认值 1
                                                            ; 新建行为体时 , 行为体可以从这个列表中随机获取一个标签
```

⚠️判断原型是否拥有标签时，将只判断 `Tags` 属性。



## 记忆体与变量与数据

每个行为体都拥有一个记忆体，你可以把变量（和它的值）保存进记忆体中。  
记忆体的生命周期和行为体一致，除非手动清空记忆体中的变量，否则保存在记忆体中的变量会持久存在，直到行为体寿命终止。

⚠️变量本身就一种标签，但是和标签不同的是，变量不拥有`标签值`，因此无法参与`标签值`判断（此处`标签值`强制视为默认值 1）。

变量会持久保存一个或一组数据，变量的类型决定了数据的类型。  
两个变量之间可以进行运算，只有类型一致的变量才能进行运算，否则会弹窗。

触发器的触发过程、效果器的效果过程等等都是一个过程。  
如果一个变量没有保存在任何记忆体中，那么过程结束后，这个变量和它的数据便会被丢弃，无法恢复。

### 给记忆体设置变量和初始值

⚠️只有拥有 Prototype 的行为体才支持设置变量和初始值。

```ini
[SomeBehaviorPrototype]
; 继承自 RawBuffablePrototype
DataMemory.XXX=<VarName>,<VarType>,[Value...]               ; 变量参数列表 , XXX 是可以随便写的 , 不要超过 32 个字符 , 只是为了标签不重名
                                                            ; VarName = 变量名称 , 必要 , 可以是纯数字以外的任意字符组合 , 但是长度不少少于 4 个字符
                                                            ; VarType = 变量类型 , 必要
                                                            ;     取值范围 :
                                                            ;     int        = 整数
                                                            ;     double     = 浮点数
                                                            ;     string     = 文本
                                                            ;     techno     = 单位
                                                            ;     technoType = 单位类型
                                                            ; Value   = 值 , 可选 , 可以写多项 , 类型需要和变量匹配 , 否则可能弹窗 , 默认值 : 空
```

### 变量运算符

在**变量名称**的前面可以追加运算符，这是一个语法优化。  
当一个变量要保存进记忆体中时，会检测记忆体中是否保存过同名变量，没保存就执行 A 类运算符，保存过就执行 B 类运算符。  
**操作变量**是要保存进记忆体中的变量，**被操作变量**是已经保存在记忆体中的变量。

|针对没保存过的变量的运算符（A 类）|说明|备注|
|:-:|:-|:-|
|`$变量名`|没保存过同名变量就添加它|默认值|
|`@变量名`|没保存过同名变量就忽略它||

|针对保存过的变量的运算符（B 类）|说明|备注|
|:-:|:-|:-|
|`=变量名`|替换|默认值|
|`~变量名`|忽略||
|`+变量名`|追加||
|`-变量名`|排除||
|`&变量名`|交集||
|`\|变量名`|并集||
|`^变量名`|异或|取**被操作变量**中存在但是**操作变量**中不存在的值|

A 类和 B 类运算符只能存在一个，且要求 A 类在 B 类前面，可以直接写 B 类运算符。  
如果只写 B 类运算符或写成了 BA 的形式，则 A 类运算符取默认值。